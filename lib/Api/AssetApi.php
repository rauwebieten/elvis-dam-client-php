<?php
/**
 * AssetApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Elvis REST API
 *
 * <h3>BETA NOTICE</h3> <div class=\"beta-notice\">This API is still in development. All API methods are functional, they are however subject to change in future Elvis versions.</div> <h3>Intro</h3> <div class=\"intro\">The Elvis REST API allows you to customize and integrate external applications with Elvis. Some examples of what you can do with the API:</div> <ul><li>Search assets.</li> <li>Download assets, previews, or other renditions.</li>  <li>Upload new assets.</li>  <li>Change asset metadata.</li>  <li>Search, create, rename and delete folders.</li>  <li>Create Shared Links.</li>  </ul><h3>Try out API methods</h3> On this page, you can try out new API methods. Before you can try them out, authorization is required. There is no authorization method in this API (yet), this means we will use the old API auth method:<br/><br/> 1. Authenticate using <span class=\"inline-code\">/services/apilogin</span> For example:<br/><br/> <pre>curl -X POST http://localhost:8080/services/apilogin -F username=admin -F password=changemenow</pre><br/> 2. Copy the authToken.<br/> 3. Click the Authorize button and use 'Bearer &lt;authToken&gt;' as value.<br/> 4. Click Authorize, the page is now authorized and you can try out the API methods.
 *
 * OpenAPI spec version: 3.0.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.12
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * AssetApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class AssetApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation asset
     *
     * Get Asset
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HitElement
     */
    public function asset($id)
    {
        list($response) = $this->assetWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation assetWithHttpInfo
     *
     * Get Asset
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HitElement, HTTP status code, HTTP response headers (array of strings)
     */
    public function assetWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\HitElement';
        $request = $this->assetRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HitElement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation assetAsync
     *
     * Get Asset
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assetAsync($id)
    {
        return $this->assetAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation assetAsyncWithHttpInfo
     *
     * Get Asset
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function assetAsyncWithHttpInfo($id)
    {
        $returnType = '\Swagger\Client\Model\HitElement';
        $request = $this->assetRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'asset'
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function assetRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling asset'
            );
        }

        $resourcePath = '/api/asset/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createAsset
     *
     * Create an asset
     *
     * @param  \Swagger\Client\Model\CreateAssetRequest $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\CreateAssetResponse
     */
    public function createAsset($body)
    {
        list($response) = $this->createAssetWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation createAssetWithHttpInfo
     *
     * Create an asset
     *
     * @param  \Swagger\Client\Model\CreateAssetRequest $body body (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\CreateAssetResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createAssetWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\CreateAssetResponse';
        $request = $this->createAssetRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\CreateAssetResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createAssetAsync
     *
     * Create an asset
     *
     * @param  \Swagger\Client\Model\CreateAssetRequest $body body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAssetAsync($body)
    {
        return $this->createAssetAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createAssetAsyncWithHttpInfo
     *
     * Create an asset
     *
     * @param  \Swagger\Client\Model\CreateAssetRequest $body body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createAssetAsyncWithHttpInfo($body)
    {
        $returnType = '\Swagger\Client\Model\CreateAssetResponse';
        $request = $this->createAssetRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createAsset'
     *
     * @param  \Swagger\Client\Model\CreateAssetRequest $body body (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createAssetRequest($body)
    {
        // verify the required parameter 'body' is set
        if ($body === null || (is_array($body) && count($body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $body when calling createAsset'
            );
        }

        $resourcePath = '/api/asset';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSignedImageRenditionUrls
     *
     * Get a signed URL for image renditions.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of minutes the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     * @param  string $format Requested image rendition format. Valid values are jpg, png or tiff (optional)
     * @param  double $scale Scales the width and height of the rendition relative to the original size. The scale is in percentages from 1 to 100. If used in combination with maxWidth or maxHeight the image will be scaled with a maximum size. (optional)
     * @param  int $max_width Sets the maximum width of the preview. The aspect ratio will always remain the same. If the original asset fits within the supplied dimensions, the original width and height will be used for generating the rendition. (optional)
     * @param  int $max_height Sets the maximum height of the preview. The aspect ratio will always remain the same. If the original asset fits within the supplied dimensions, the original width and height will be used for generating the rendition. (optional)
     * @param  int $ppi The pixels per inch / dots per inch can be set to any desired value. When not set, the original PPI / DPI value of the asset will be used. (optional)
     * @param  bool $embed_metadata When set to true, the metadata embedded in the original asset will be embedded in the generated rendition. Note that for certain file types the embedding of metadata is not supported, for example for PNG files. By default the original metadata is not embedded. (optional)
     * @param  bool $embed_color_profile When set to true, the color profile that is used to generate the rendition is included. (optional)
     * @param  string $compression TIFF Compression type, applicable when format&#x3D;&#39;tif&#39;. Allowed values: uncompressed, packBits, LZW, ZIP and JPEG. (optional)
     * @param  int $quality JPEG compression, applicable when format&#x3D;&#39;jpg&#39;. The quality is defined a value from 1 to 100. (optional)
     * @param  bool $watermarked When set to true, a watermark is applied to the rendition. Note: a watermark needs to be configured in the server configuration. (optional)
     * @param  string $background Sets the background color (hex color code) for transparent images. If not specified, the output of PNG and TIFF images will be transparent. (optional)
     * @param  int $crop_width Sets the width (in pixels) to which the image should be cropped. (optional)
     * @param  int $crop_height Sets the height (in pixels) to which the image should be cropped. (optional)
     * @param  int $crop_offset_x Sets the crop x offset in pixels (from the top left corner). (optional)
     * @param  int $crop_offset_y Sets the crop y offset in pixels (from the top left corner). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SignedAssetUrl[]
     */
    public function getSignedImageRenditionUrls($ids, $valid_for = '600', $format = null, $scale = null, $max_width = null, $max_height = null, $ppi = null, $embed_metadata = null, $embed_color_profile = null, $compression = null, $quality = null, $watermarked = null, $background = null, $crop_width = null, $crop_height = null, $crop_offset_x = null, $crop_offset_y = null)
    {
        list($response) = $this->getSignedImageRenditionUrlsWithHttpInfo($ids, $valid_for, $format, $scale, $max_width, $max_height, $ppi, $embed_metadata, $embed_color_profile, $compression, $quality, $watermarked, $background, $crop_width, $crop_height, $crop_offset_x, $crop_offset_y);
        return $response;
    }

    /**
     * Operation getSignedImageRenditionUrlsWithHttpInfo
     *
     * Get a signed URL for image renditions.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of minutes the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     * @param  string $format Requested image rendition format. Valid values are jpg, png or tiff (optional)
     * @param  double $scale Scales the width and height of the rendition relative to the original size. The scale is in percentages from 1 to 100. If used in combination with maxWidth or maxHeight the image will be scaled with a maximum size. (optional)
     * @param  int $max_width Sets the maximum width of the preview. The aspect ratio will always remain the same. If the original asset fits within the supplied dimensions, the original width and height will be used for generating the rendition. (optional)
     * @param  int $max_height Sets the maximum height of the preview. The aspect ratio will always remain the same. If the original asset fits within the supplied dimensions, the original width and height will be used for generating the rendition. (optional)
     * @param  int $ppi The pixels per inch / dots per inch can be set to any desired value. When not set, the original PPI / DPI value of the asset will be used. (optional)
     * @param  bool $embed_metadata When set to true, the metadata embedded in the original asset will be embedded in the generated rendition. Note that for certain file types the embedding of metadata is not supported, for example for PNG files. By default the original metadata is not embedded. (optional)
     * @param  bool $embed_color_profile When set to true, the color profile that is used to generate the rendition is included. (optional)
     * @param  string $compression TIFF Compression type, applicable when format&#x3D;&#39;tif&#39;. Allowed values: uncompressed, packBits, LZW, ZIP and JPEG. (optional)
     * @param  int $quality JPEG compression, applicable when format&#x3D;&#39;jpg&#39;. The quality is defined a value from 1 to 100. (optional)
     * @param  bool $watermarked When set to true, a watermark is applied to the rendition. Note: a watermark needs to be configured in the server configuration. (optional)
     * @param  string $background Sets the background color (hex color code) for transparent images. If not specified, the output of PNG and TIFF images will be transparent. (optional)
     * @param  int $crop_width Sets the width (in pixels) to which the image should be cropped. (optional)
     * @param  int $crop_height Sets the height (in pixels) to which the image should be cropped. (optional)
     * @param  int $crop_offset_x Sets the crop x offset in pixels (from the top left corner). (optional)
     * @param  int $crop_offset_y Sets the crop y offset in pixels (from the top left corner). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SignedAssetUrl[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getSignedImageRenditionUrlsWithHttpInfo($ids, $valid_for = '600', $format = null, $scale = null, $max_width = null, $max_height = null, $ppi = null, $embed_metadata = null, $embed_color_profile = null, $compression = null, $quality = null, $watermarked = null, $background = null, $crop_width = null, $crop_height = null, $crop_offset_x = null, $crop_offset_y = null)
    {
        $returnType = '\Swagger\Client\Model\SignedAssetUrl[]';
        $request = $this->getSignedImageRenditionUrlsRequest($ids, $valid_for, $format, $scale, $max_width, $max_height, $ppi, $embed_metadata, $embed_color_profile, $compression, $quality, $watermarked, $background, $crop_width, $crop_height, $crop_offset_x, $crop_offset_y);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SignedAssetUrl[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSignedImageRenditionUrlsAsync
     *
     * Get a signed URL for image renditions.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of minutes the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     * @param  string $format Requested image rendition format. Valid values are jpg, png or tiff (optional)
     * @param  double $scale Scales the width and height of the rendition relative to the original size. The scale is in percentages from 1 to 100. If used in combination with maxWidth or maxHeight the image will be scaled with a maximum size. (optional)
     * @param  int $max_width Sets the maximum width of the preview. The aspect ratio will always remain the same. If the original asset fits within the supplied dimensions, the original width and height will be used for generating the rendition. (optional)
     * @param  int $max_height Sets the maximum height of the preview. The aspect ratio will always remain the same. If the original asset fits within the supplied dimensions, the original width and height will be used for generating the rendition. (optional)
     * @param  int $ppi The pixels per inch / dots per inch can be set to any desired value. When not set, the original PPI / DPI value of the asset will be used. (optional)
     * @param  bool $embed_metadata When set to true, the metadata embedded in the original asset will be embedded in the generated rendition. Note that for certain file types the embedding of metadata is not supported, for example for PNG files. By default the original metadata is not embedded. (optional)
     * @param  bool $embed_color_profile When set to true, the color profile that is used to generate the rendition is included. (optional)
     * @param  string $compression TIFF Compression type, applicable when format&#x3D;&#39;tif&#39;. Allowed values: uncompressed, packBits, LZW, ZIP and JPEG. (optional)
     * @param  int $quality JPEG compression, applicable when format&#x3D;&#39;jpg&#39;. The quality is defined a value from 1 to 100. (optional)
     * @param  bool $watermarked When set to true, a watermark is applied to the rendition. Note: a watermark needs to be configured in the server configuration. (optional)
     * @param  string $background Sets the background color (hex color code) for transparent images. If not specified, the output of PNG and TIFF images will be transparent. (optional)
     * @param  int $crop_width Sets the width (in pixels) to which the image should be cropped. (optional)
     * @param  int $crop_height Sets the height (in pixels) to which the image should be cropped. (optional)
     * @param  int $crop_offset_x Sets the crop x offset in pixels (from the top left corner). (optional)
     * @param  int $crop_offset_y Sets the crop y offset in pixels (from the top left corner). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSignedImageRenditionUrlsAsync($ids, $valid_for = '600', $format = null, $scale = null, $max_width = null, $max_height = null, $ppi = null, $embed_metadata = null, $embed_color_profile = null, $compression = null, $quality = null, $watermarked = null, $background = null, $crop_width = null, $crop_height = null, $crop_offset_x = null, $crop_offset_y = null)
    {
        return $this->getSignedImageRenditionUrlsAsyncWithHttpInfo($ids, $valid_for, $format, $scale, $max_width, $max_height, $ppi, $embed_metadata, $embed_color_profile, $compression, $quality, $watermarked, $background, $crop_width, $crop_height, $crop_offset_x, $crop_offset_y)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSignedImageRenditionUrlsAsyncWithHttpInfo
     *
     * Get a signed URL for image renditions.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of minutes the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     * @param  string $format Requested image rendition format. Valid values are jpg, png or tiff (optional)
     * @param  double $scale Scales the width and height of the rendition relative to the original size. The scale is in percentages from 1 to 100. If used in combination with maxWidth or maxHeight the image will be scaled with a maximum size. (optional)
     * @param  int $max_width Sets the maximum width of the preview. The aspect ratio will always remain the same. If the original asset fits within the supplied dimensions, the original width and height will be used for generating the rendition. (optional)
     * @param  int $max_height Sets the maximum height of the preview. The aspect ratio will always remain the same. If the original asset fits within the supplied dimensions, the original width and height will be used for generating the rendition. (optional)
     * @param  int $ppi The pixels per inch / dots per inch can be set to any desired value. When not set, the original PPI / DPI value of the asset will be used. (optional)
     * @param  bool $embed_metadata When set to true, the metadata embedded in the original asset will be embedded in the generated rendition. Note that for certain file types the embedding of metadata is not supported, for example for PNG files. By default the original metadata is not embedded. (optional)
     * @param  bool $embed_color_profile When set to true, the color profile that is used to generate the rendition is included. (optional)
     * @param  string $compression TIFF Compression type, applicable when format&#x3D;&#39;tif&#39;. Allowed values: uncompressed, packBits, LZW, ZIP and JPEG. (optional)
     * @param  int $quality JPEG compression, applicable when format&#x3D;&#39;jpg&#39;. The quality is defined a value from 1 to 100. (optional)
     * @param  bool $watermarked When set to true, a watermark is applied to the rendition. Note: a watermark needs to be configured in the server configuration. (optional)
     * @param  string $background Sets the background color (hex color code) for transparent images. If not specified, the output of PNG and TIFF images will be transparent. (optional)
     * @param  int $crop_width Sets the width (in pixels) to which the image should be cropped. (optional)
     * @param  int $crop_height Sets the height (in pixels) to which the image should be cropped. (optional)
     * @param  int $crop_offset_x Sets the crop x offset in pixels (from the top left corner). (optional)
     * @param  int $crop_offset_y Sets the crop y offset in pixels (from the top left corner). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSignedImageRenditionUrlsAsyncWithHttpInfo($ids, $valid_for = '600', $format = null, $scale = null, $max_width = null, $max_height = null, $ppi = null, $embed_metadata = null, $embed_color_profile = null, $compression = null, $quality = null, $watermarked = null, $background = null, $crop_width = null, $crop_height = null, $crop_offset_x = null, $crop_offset_y = null)
    {
        $returnType = '\Swagger\Client\Model\SignedAssetUrl[]';
        $request = $this->getSignedImageRenditionUrlsRequest($ids, $valid_for, $format, $scale, $max_width, $max_height, $ppi, $embed_metadata, $embed_color_profile, $compression, $quality, $watermarked, $background, $crop_width, $crop_height, $crop_offset_x, $crop_offset_y);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSignedImageRenditionUrls'
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of minutes the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     * @param  string $format Requested image rendition format. Valid values are jpg, png or tiff (optional)
     * @param  double $scale Scales the width and height of the rendition relative to the original size. The scale is in percentages from 1 to 100. If used in combination with maxWidth or maxHeight the image will be scaled with a maximum size. (optional)
     * @param  int $max_width Sets the maximum width of the preview. The aspect ratio will always remain the same. If the original asset fits within the supplied dimensions, the original width and height will be used for generating the rendition. (optional)
     * @param  int $max_height Sets the maximum height of the preview. The aspect ratio will always remain the same. If the original asset fits within the supplied dimensions, the original width and height will be used for generating the rendition. (optional)
     * @param  int $ppi The pixels per inch / dots per inch can be set to any desired value. When not set, the original PPI / DPI value of the asset will be used. (optional)
     * @param  bool $embed_metadata When set to true, the metadata embedded in the original asset will be embedded in the generated rendition. Note that for certain file types the embedding of metadata is not supported, for example for PNG files. By default the original metadata is not embedded. (optional)
     * @param  bool $embed_color_profile When set to true, the color profile that is used to generate the rendition is included. (optional)
     * @param  string $compression TIFF Compression type, applicable when format&#x3D;&#39;tif&#39;. Allowed values: uncompressed, packBits, LZW, ZIP and JPEG. (optional)
     * @param  int $quality JPEG compression, applicable when format&#x3D;&#39;jpg&#39;. The quality is defined a value from 1 to 100. (optional)
     * @param  bool $watermarked When set to true, a watermark is applied to the rendition. Note: a watermark needs to be configured in the server configuration. (optional)
     * @param  string $background Sets the background color (hex color code) for transparent images. If not specified, the output of PNG and TIFF images will be transparent. (optional)
     * @param  int $crop_width Sets the width (in pixels) to which the image should be cropped. (optional)
     * @param  int $crop_height Sets the height (in pixels) to which the image should be cropped. (optional)
     * @param  int $crop_offset_x Sets the crop x offset in pixels (from the top left corner). (optional)
     * @param  int $crop_offset_y Sets the crop y offset in pixels (from the top left corner). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSignedImageRenditionUrlsRequest($ids, $valid_for = '600', $format = null, $scale = null, $max_width = null, $max_height = null, $ppi = null, $embed_metadata = null, $embed_color_profile = null, $compression = null, $quality = null, $watermarked = null, $background = null, $crop_width = null, $crop_height = null, $crop_offset_x = null, $crop_offset_y = null)
    {
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling getSignedImageRenditionUrls'
            );
        }

        $resourcePath = '/api/asset/{ids}/signed-image-rendition-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($valid_for !== null) {
            $queryParams['validFor'] = ObjectSerializer::toQueryValue($valid_for);
        }
        // query params
        if ($format !== null) {
            $queryParams['format'] = ObjectSerializer::toQueryValue($format);
        }
        // query params
        if ($scale !== null) {
            $queryParams['scale'] = ObjectSerializer::toQueryValue($scale);
        }
        // query params
        if ($max_width !== null) {
            $queryParams['maxWidth'] = ObjectSerializer::toQueryValue($max_width);
        }
        // query params
        if ($max_height !== null) {
            $queryParams['maxHeight'] = ObjectSerializer::toQueryValue($max_height);
        }
        // query params
        if ($ppi !== null) {
            $queryParams['ppi'] = ObjectSerializer::toQueryValue($ppi);
        }
        // query params
        if ($embed_metadata !== null) {
            $queryParams['embedMetadata'] = ObjectSerializer::toQueryValue($embed_metadata);
        }
        // query params
        if ($embed_color_profile !== null) {
            $queryParams['embedColorProfile'] = ObjectSerializer::toQueryValue($embed_color_profile);
        }
        // query params
        if ($compression !== null) {
            $queryParams['compression'] = ObjectSerializer::toQueryValue($compression);
        }
        // query params
        if ($quality !== null) {
            $queryParams['quality'] = ObjectSerializer::toQueryValue($quality);
        }
        // query params
        if ($watermarked !== null) {
            $queryParams['watermarked'] = ObjectSerializer::toQueryValue($watermarked);
        }
        // query params
        if ($background !== null) {
            $queryParams['background'] = ObjectSerializer::toQueryValue($background);
        }
        // query params
        if ($crop_width !== null) {
            $queryParams['cropWidth'] = ObjectSerializer::toQueryValue($crop_width);
        }
        // query params
        if ($crop_height !== null) {
            $queryParams['cropHeight'] = ObjectSerializer::toQueryValue($crop_height);
        }
        // query params
        if ($crop_offset_x !== null) {
            $queryParams['cropOffsetX'] = ObjectSerializer::toQueryValue($crop_offset_x);
        }
        // query params
        if ($crop_offset_y !== null) {
            $queryParams['cropOffsetY'] = ObjectSerializer::toQueryValue($crop_offset_y);
        }

        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSignedOriginalUrls
     *
     * Get a signed URL for original assets.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SignedAssetUrl[]
     */
    public function getSignedOriginalUrls($ids, $valid_for = '600')
    {
        list($response) = $this->getSignedOriginalUrlsWithHttpInfo($ids, $valid_for);
        return $response;
    }

    /**
     * Operation getSignedOriginalUrlsWithHttpInfo
     *
     * Get a signed URL for original assets.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SignedAssetUrl[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getSignedOriginalUrlsWithHttpInfo($ids, $valid_for = '600')
    {
        $returnType = '\Swagger\Client\Model\SignedAssetUrl[]';
        $request = $this->getSignedOriginalUrlsRequest($ids, $valid_for);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SignedAssetUrl[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSignedOriginalUrlsAsync
     *
     * Get a signed URL for original assets.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSignedOriginalUrlsAsync($ids, $valid_for = '600')
    {
        return $this->getSignedOriginalUrlsAsyncWithHttpInfo($ids, $valid_for)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSignedOriginalUrlsAsyncWithHttpInfo
     *
     * Get a signed URL for original assets.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSignedOriginalUrlsAsyncWithHttpInfo($ids, $valid_for = '600')
    {
        $returnType = '\Swagger\Client\Model\SignedAssetUrl[]';
        $request = $this->getSignedOriginalUrlsRequest($ids, $valid_for);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSignedOriginalUrls'
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSignedOriginalUrlsRequest($ids, $valid_for = '600')
    {
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling getSignedOriginalUrls'
            );
        }

        $resourcePath = '/api/asset/{ids}/signed-original-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($valid_for !== null) {
            $queryParams['validFor'] = ObjectSerializer::toQueryValue($valid_for);
        }

        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSignedPreviewUrls
     *
     * Get a signed URL for asset previews.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SignedAssetUrl[]
     */
    public function getSignedPreviewUrls($ids, $valid_for = '600')
    {
        list($response) = $this->getSignedPreviewUrlsWithHttpInfo($ids, $valid_for);
        return $response;
    }

    /**
     * Operation getSignedPreviewUrlsWithHttpInfo
     *
     * Get a signed URL for asset previews.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SignedAssetUrl[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getSignedPreviewUrlsWithHttpInfo($ids, $valid_for = '600')
    {
        $returnType = '\Swagger\Client\Model\SignedAssetUrl[]';
        $request = $this->getSignedPreviewUrlsRequest($ids, $valid_for);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SignedAssetUrl[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSignedPreviewUrlsAsync
     *
     * Get a signed URL for asset previews.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSignedPreviewUrlsAsync($ids, $valid_for = '600')
    {
        return $this->getSignedPreviewUrlsAsyncWithHttpInfo($ids, $valid_for)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSignedPreviewUrlsAsyncWithHttpInfo
     *
     * Get a signed URL for asset previews.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSignedPreviewUrlsAsyncWithHttpInfo($ids, $valid_for = '600')
    {
        $returnType = '\Swagger\Client\Model\SignedAssetUrl[]';
        $request = $this->getSignedPreviewUrlsRequest($ids, $valid_for);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSignedPreviewUrls'
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSignedPreviewUrlsRequest($ids, $valid_for = '600')
    {
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling getSignedPreviewUrls'
            );
        }

        $resourcePath = '/api/asset/{ids}/signed-preview-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($valid_for !== null) {
            $queryParams['validFor'] = ObjectSerializer::toQueryValue($valid_for);
        }

        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSignedThumbnailUrls
     *
     * Get a signed URL for asset thumbnails.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SignedAssetUrl[]
     */
    public function getSignedThumbnailUrls($ids, $valid_for = '600')
    {
        list($response) = $this->getSignedThumbnailUrlsWithHttpInfo($ids, $valid_for);
        return $response;
    }

    /**
     * Operation getSignedThumbnailUrlsWithHttpInfo
     *
     * Get a signed URL for asset thumbnails.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SignedAssetUrl[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getSignedThumbnailUrlsWithHttpInfo($ids, $valid_for = '600')
    {
        $returnType = '\Swagger\Client\Model\SignedAssetUrl[]';
        $request = $this->getSignedThumbnailUrlsRequest($ids, $valid_for);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SignedAssetUrl[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSignedThumbnailUrlsAsync
     *
     * Get a signed URL for asset thumbnails.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSignedThumbnailUrlsAsync($ids, $valid_for = '600')
    {
        return $this->getSignedThumbnailUrlsAsyncWithHttpInfo($ids, $valid_for)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSignedThumbnailUrlsAsyncWithHttpInfo
     *
     * Get a signed URL for asset thumbnails.
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSignedThumbnailUrlsAsyncWithHttpInfo($ids, $valid_for = '600')
    {
        $returnType = '\Swagger\Client\Model\SignedAssetUrl[]';
        $request = $this->getSignedThumbnailUrlsRequest($ids, $valid_for);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSignedThumbnailUrls'
     *
     * @param  string $ids Comma separated list of asset id&#39;s (required)
     * @param  int $valid_for Amount of seconds the url is valid, specify -1 to obtain a url which is valid forever (optional, default to 600)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getSignedThumbnailUrlsRequest($ids, $valid_for = '600')
    {
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling getSignedThumbnailUrls'
            );
        }

        $resourcePath = '/api/asset/{ids}/signed-thumbnail-url';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($valid_for !== null) {
            $queryParams['validFor'] = ObjectSerializer::toQueryValue($valid_for);
        }

        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation original
     *
     * Download Asset Original
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function original($id)
    {
        list($response) = $this->originalWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation originalWithHttpInfo
     *
     * Download Asset Original
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function originalWithHttpInfo($id)
    {
        $returnType = '\SplFileObject';
        $request = $this->originalRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation originalAsync
     *
     * Download Asset Original
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originalAsync($id)
    {
        return $this->originalAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation originalAsyncWithHttpInfo
     *
     * Download Asset Original
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function originalAsyncWithHttpInfo($id)
    {
        $returnType = '\SplFileObject';
        $request = $this->originalRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'original'
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function originalRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling original'
            );
        }

        $resourcePath = '/api/asset/{id}/original';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation preview
     *
     * Download Asset Preview
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function preview($id)
    {
        list($response) = $this->previewWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation previewWithHttpInfo
     *
     * Download Asset Preview
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function previewWithHttpInfo($id)
    {
        $returnType = '\SplFileObject';
        $request = $this->previewRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation previewAsync
     *
     * Download Asset Preview
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function previewAsync($id)
    {
        return $this->previewAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation previewAsyncWithHttpInfo
     *
     * Download Asset Preview
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function previewAsyncWithHttpInfo($id)
    {
        $returnType = '\SplFileObject';
        $request = $this->previewRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'preview'
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function previewRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling preview'
            );
        }

        $resourcePath = '/api/asset/{id}/preview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putOriginal
     *
     * Upload a file for an asset using PUT.
     *
     * @param  string $id id (required)
     * @param  bool $create_version createVersion (optional, default to true)
     * @param  object $file file (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HitElement
     */
    public function putOriginal($id, $create_version = 'true', $file = null)
    {
        list($response) = $this->putOriginalWithHttpInfo($id, $create_version, $file);
        return $response;
    }

    /**
     * Operation putOriginalWithHttpInfo
     *
     * Upload a file for an asset using PUT.
     *
     * @param  string $id id (required)
     * @param  bool $create_version createVersion (optional, default to true)
     * @param  object $file (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HitElement, HTTP status code, HTTP response headers (array of strings)
     */
    public function putOriginalWithHttpInfo($id, $create_version = 'true', $file = null)
    {
        $returnType = '\Swagger\Client\Model\HitElement';
        $request = $this->putOriginalRequest($id, $create_version, $file);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HitElement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putOriginalAsync
     *
     * Upload a file for an asset using PUT.
     *
     * @param  string $id id (required)
     * @param  bool $create_version createVersion (optional, default to true)
     * @param  object $file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putOriginalAsync($id, $create_version = 'true', $file = null)
    {
        return $this->putOriginalAsyncWithHttpInfo($id, $create_version, $file)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putOriginalAsyncWithHttpInfo
     *
     * Upload a file for an asset using PUT.
     *
     * @param  string $id id (required)
     * @param  bool $create_version createVersion (optional, default to true)
     * @param  object $file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putOriginalAsyncWithHttpInfo($id, $create_version = 'true', $file = null)
    {
        $returnType = '\Swagger\Client\Model\HitElement';
        $request = $this->putOriginalRequest($id, $create_version, $file);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putOriginal'
     *
     * @param  string $id id (required)
     * @param  bool $create_version createVersion (optional, default to true)
     * @param  object $file (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function putOriginalRequest($id, $create_version = 'true', $file = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling putOriginal'
            );
        }

        $resourcePath = '/api/asset/{id}/original';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($create_version !== null) {
            $queryParams['createVersion'] = ObjectSerializer::toQueryValue($create_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($file)) {
            $_tempBody = $file;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation search
     *
     * Search Assets
     *
     * @param  string $q The search query. (optional)
     * @param  int $from The offset from the first result you want to fetch. (optional, default to 0)
     * @param  int $size The maximum amount of hits to be returned. (optional, default to 10)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SearchResponse
     */
    public function search($q = null, $from = '0', $size = '10')
    {
        list($response) = $this->searchWithHttpInfo($q, $from, $size);
        return $response;
    }

    /**
     * Operation searchWithHttpInfo
     *
     * Search Assets
     *
     * @param  string $q The search query. (optional)
     * @param  int $from The offset from the first result you want to fetch. (optional, default to 0)
     * @param  int $size The maximum amount of hits to be returned. (optional, default to 10)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchWithHttpInfo($q = null, $from = '0', $size = '10')
    {
        $returnType = '\Swagger\Client\Model\SearchResponse';
        $request = $this->searchRequest($q, $from, $size);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchAsync
     *
     * Search Assets
     *
     * @param  string $q The search query. (optional)
     * @param  int $from The offset from the first result you want to fetch. (optional, default to 0)
     * @param  int $size The maximum amount of hits to be returned. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsync($q = null, $from = '0', $size = '10')
    {
        return $this->searchAsyncWithHttpInfo($q, $from, $size)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchAsyncWithHttpInfo
     *
     * Search Assets
     *
     * @param  string $q The search query. (optional)
     * @param  int $from The offset from the first result you want to fetch. (optional, default to 0)
     * @param  int $size The maximum amount of hits to be returned. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchAsyncWithHttpInfo($q = null, $from = '0', $size = '10')
    {
        $returnType = '\Swagger\Client\Model\SearchResponse';
        $request = $this->searchRequest($q, $from, $size);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'search'
     *
     * @param  string $q The search query. (optional)
     * @param  int $from The offset from the first result you want to fetch. (optional, default to 0)
     * @param  int $size The maximum amount of hits to be returned. (optional, default to 10)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchRequest($q = null, $from = '0', $size = '10')
    {

        $resourcePath = '/api/asset/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($q !== null) {
            $queryParams['q'] = ObjectSerializer::toQueryValue($q);
        }
        // query params
        if ($from !== null) {
            $queryParams['from'] = ObjectSerializer::toQueryValue($from);
        }
        // query params
        if ($size !== null) {
            $queryParams['size'] = ObjectSerializer::toQueryValue($size);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation thumbnail
     *
     * Download Asset Thumbnail
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function thumbnail($id)
    {
        list($response) = $this->thumbnailWithHttpInfo($id);
        return $response;
    }

    /**
     * Operation thumbnailWithHttpInfo
     *
     * Download Asset Thumbnail
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function thumbnailWithHttpInfo($id)
    {
        $returnType = '\SplFileObject';
        $request = $this->thumbnailRequest($id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation thumbnailAsync
     *
     * Download Asset Thumbnail
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function thumbnailAsync($id)
    {
        return $this->thumbnailAsyncWithHttpInfo($id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation thumbnailAsyncWithHttpInfo
     *
     * Download Asset Thumbnail
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function thumbnailAsyncWithHttpInfo($id)
    {
        $returnType = '\SplFileObject';
        $request = $this->thumbnailRequest($id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'thumbnail'
     *
     * @param  string $id Asset identifier (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function thumbnailRequest($id)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling thumbnail'
            );
        }

        $resourcePath = '/api/asset/{id}/thumbnail';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadOriginal
     *
     * Upload a file for an asset using multi-part POST.
     *
     * @param  string $id id (required)
     * @param  \SplFileObject $file file (required)
     * @param  bool $create_version createVersion (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\HitElement
     */
    public function uploadOriginal($id, $file, $create_version = 'true')
    {
        list($response) = $this->uploadOriginalWithHttpInfo($id, $file, $create_version);
        return $response;
    }

    /**
     * Operation uploadOriginalWithHttpInfo
     *
     * Upload a file for an asset using multi-part POST.
     *
     * @param  string $id id (required)
     * @param  \SplFileObject $file file (required)
     * @param  bool $create_version createVersion (optional, default to true)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\HitElement, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadOriginalWithHttpInfo($id, $file, $create_version = 'true')
    {
        $returnType = '\Swagger\Client\Model\HitElement';
        $request = $this->uploadOriginalRequest($id, $file, $create_version);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\HitElement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation uploadOriginalAsync
     *
     * Upload a file for an asset using multi-part POST.
     *
     * @param  string $id id (required)
     * @param  \SplFileObject $file file (required)
     * @param  bool $create_version createVersion (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadOriginalAsync($id, $file, $create_version = 'true')
    {
        return $this->uploadOriginalAsyncWithHttpInfo($id, $file, $create_version)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadOriginalAsyncWithHttpInfo
     *
     * Upload a file for an asset using multi-part POST.
     *
     * @param  string $id id (required)
     * @param  \SplFileObject $file file (required)
     * @param  bool $create_version createVersion (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadOriginalAsyncWithHttpInfo($id, $file, $create_version = 'true')
    {
        $returnType = '\Swagger\Client\Model\HitElement';
        $request = $this->uploadOriginalRequest($id, $file, $create_version);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadOriginal'
     *
     * @param  string $id id (required)
     * @param  \SplFileObject $file file (required)
     * @param  bool $create_version createVersion (optional, default to true)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function uploadOriginalRequest($id, $file, $create_version = 'true')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling uploadOriginal'
            );
        }
        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling uploadOriginal'
            );
        }

        $resourcePath = '/api/asset/{id}/original';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($create_version !== null) {
            $queryParams['createVersion'] = ObjectSerializer::toQueryValue($create_version);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // form params
        if ($file !== null) {
            $multipart = true;
            $formParams['file'] = \GuzzleHttp\Psr7\try_fopen(ObjectSerializer::toFormValue($file), 'rb');
        }
        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['multipart/form-data']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
